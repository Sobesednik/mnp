#!/usr/bin/env node
'use strict'

const makePromise = require('makepromise')
const os = require('os')
const path = require('path')
const spawnCommand = require('spawncommand')
const wrote = require('wrote')

const askQuestions = require('../src/ask-questions')
const lib = require('../src/lib')
const CWD = process.cwd()

const DEFAULT_CONFIG_PATH = path.join(__dirname, '../etc/default-config.json')
const CONFIG_PATH = path.join(os.homedir(), '/.mnp.json')

const DEFAULT_STRUCTURE_PATH = path.join(__dirname, '../structures/my-new-package/')
const ANSWER_TIMEOUT = undefined

/**
 * Initialise default config
 */
function init() {
    const questions = {
        token: {
            text: 'GitHub access token: ',
            validation: (a) => {
                if (!a) {
                    throw new Error('Please specify token')
                }
            },
        },
        org: {
            text: 'Organisation: ',
            defaultValue: null,
        },
        name: {
            getDefault: () => git(['config', 'user.name'], true)
                .then((res) => {
                    return res.stdout.trim()
                }),
            text: 'user',
        },
        email: {
            getDefault: () => git(['config', 'user.email'], true)
                .then((res) => {
                    return res.stdout.trim()
                }),
            text: 'email',
        },
    }
    return askQuestions(questions)
}

function updateConfig(newConfig, configPath) {
    return wrote(configPath).then((ws) => {
        console.log(`...updating ${configPath}`)
        return makePromise(ws.end.bind(ws), `${JSON.stringify(newConfig, null, 2)}\n`, newConfig)
    })
}

function initAndUpdate(configPath) {
    return init().then((newConfig) => {
        return updateConfig(newConfig, configPath)
    })
}

function fullInit(configPath, defaultConfigPath) {
    return lib.readConfig(configPath, defaultConfigPath).then((res) => {
        if (res.token === null) {
            return initAndUpdate(configPath)
        }
        return res
    })
}

function git(args, noPipe) {
    const proc = spawnCommand('git', args)
    if (!noPipe) {
        proc.stdout.pipe(process.stdout)
        proc.stderr.pipe(process.stderr)
    }
    return proc.promise
}

let conf
let description
let githubResult
let packagePath
let packageName
let packageJsonPath

fullInit(CONFIG_PATH, DEFAULT_CONFIG_PATH)
    .then((res) => {
        conf = res
        const argvPacakgeName = process.argv[2]
        if (argvPacakgeName) {
            return argvPacakgeName
        }
        return askQuestions({
            package_name: {
                text: 'Please give package name: ',
                validation: (a) => {
                    if (!a) throw new Error('You must specify package name')
                },
            },
        }).then(res => res.package_name)
    })
    .then((res) => {
        packageName = res
        packagePath = path.join(CWD, packageName)
        packageJsonPath = path.join(packagePath, 'package.json')
        return lib.assertDoesNotExist(packagePath)
    })
    .then(() => {
        const proc = spawnCommand('git', ['rev-parse', '--git-dir'])
        return proc.promise
    })
    .then((res) => {
        if (/\.git/.test(res.stdout)) {
            throw new Error('Current dir is in git path!')
        }
        console.log(`# ${packageName}`)
        return askQuestions({
            description: {
                text: 'Description: ',
                postProcess: s => s.trim(),
                defaultValue: '',
            },
        }, null, 'description')
    })
    .then((description) => {
        return lib.createRepo(conf.token, packageName, conf.org, description)
    })
    .then((res) => {
        githubResult = res
    })
    .then(() => {
        console.log('cloning %s', githubResult.ssh_url)
        return git(['clone', githubResult.ssh_url, packagePath])
    })
    .then(() => {
        process.chdir(packagePath)
        console.log('setting user info: %s<%s>', conf.name, conf.email)
        return git(['config', 'user.name', conf.name])
            .then(() => {
                return git(['config', 'user.email', conf.email])
            })
    })
    .then(() => {
        const proc = spawnCommand('rsync', [
            '-av',
            DEFAULT_STRUCTURE_PATH,
            packagePath,
        ])
        return proc.promise
    })
    .then((res) => {
        if (res.stderr) {
            throw new Error(res.stderr)
        }
        if (!/package\.json/.test(res.stdout)) {
            throw new Error('Expected to have copied files')
        }
        console.log(`cloned the structure to ${packagePath}`)
        const packageJson = require(packageJsonPath)
        const newPackage = Object.assign({}, packageJson, {
            name: packageName,
            repository: {
                type: 'git',
                url: githubResult.git_url,
            },
            bugs: {
                url: `${githubResult.html_url}/issues`,
            },
            author: `${conf.name} <${conf.email}>`,
            homepage: `${githubResult.html_url}#readme`,
        }, description ? { description } : {})
        console.log('Created new repo: %s', newPackage.homepage)
        return wrote(packageJsonPath)
            .then((ws) => {
                return makePromise(ws.end.bind(ws), JSON.stringify(newPackage, null, 2))
            })
    })
    .then(() => {
        return git(['add', '.'])
    })
    .then(() => {
        return git(['commit', '-m', 'initialise package'])
    })
    .then(() => {
        return git(['push', 'origin', 'master'])
    })
    .then(() => {
        console.log('success')
    })
    .catch((err) => {
        console.error(err.message)
    })
